* to create SQLAlchemy : python -m  pip install flask-sqlalchemy
* to use migration of flask : python -m pip install Flask-Migrate
* use migrate commands :
    flask db init        # initialize Alembic   : create migration folder
    flask db migrate  -m "message"   # detect schema changes   : it will create migration table inside migrations/versions
    flask db upgrade     # apply changes to DB  : create table in mysql database


* connected with flask sqlalchemy : 'mysql://username:password@localhost/db_name'

* Alembic is a database migration tool for Python applications that use SQLAlchemy.
Alembic is like a version control system for your database schema — similar to how Git tracks your code changes, Alembic tracks changes to your database tables and columns over time.

* __init__.py : Marks a folder as a Python package
and inside this add files name like from myapp import routes


* @app.context_processor
def inject_urls():
    return {key: app.config[key] for key in ['FB_URL', 'TW_URL', 'GT_URL']}

context_processor as a global variables provider for Jinja templates.You write it once, and it works everywhere — all templates get the variables without explicitly passing them.
you donot need to pass the variables manually in every route like below:
@app.route('/')
def home():
    return render_template('index.html', FB_URL=app.config['FB_URL'])


*  pip install flask-mail   : for sending mail
* for sending mail activate app password
* The core difference between using render_template and redirect after adding a user to the session is whether a new HTTP request is made.
The core difference between using render_template and redirect after adding a user to the session is whether a new HTTP request is made. This has a major impact on how the session is handled and perceived by the browser.

1. render_template After Adding to Session
When you use render_template, you are generating an HTML page and sending it as the response to the current request. No new request is initiated by the server. While the server sends the session cookie to the browser in the HTTP headers, the browser simply displays the page without a new request-response cycle.

Scenario:
User submits a form (e.g., POST request to /login).
Flask sets session['user'] = 'admin'.
Flask returns render_template('dashboard.html').
The user sees the dashboard.

Problem: The browser hasn't been instructed to make a new request with the session cookie. While the cookie is saved, if the user refreshes the page or navigates to another URL (e.g., /profile), a new GET request is made. If the session cookie wasn't properly processed by the browser after the initial render, the new request may not include it, causing the user to appear logged out. This breaks the expected behavior of a persistent session.

2. redirect After Adding to Session
Using redirect is the correct and standard way to handle form submissions that change state. It forces the browser to make a new GET request.

Scenario:
User submits a form (e.g., POST request to /login).
Flask sets session['user'] = 'admin'.
Flask returns redirect(url_for('dashboard')).
The server sends a special HTTP response (a 302 Redirect) telling the browser: "The action is complete. Now, go make a new GET request to /dashboard."
The browser saves the session cookie from the redirect response.
The browser immediately makes a new GET request to /dashboard, and sends the session cookie along with it.
The dashboard route receives this new request, sees the session cookie, and correctly identifies the user as logged in.


3. Use secure_filename() to clean the filename for security by removing potentially dangerous characters and preventing a user from uploading a file to an unintended location on your server.
    -Removing Dangerous Characters
    -Preventing Path Traversa
    -Keeping the Filename:  My File (1).jpg would be converted to My_File_1.jpg.